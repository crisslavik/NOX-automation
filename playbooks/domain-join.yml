---
- name: Join AlmaLinux 9 to AD Domain (ad.noxvfx.com)
  hosts: all
  become: yes
  vars:
    domain_name: "ad.noxvfx.com"
    domain_controller: "dc-1.ad.noxvfx.com"
    domain_admin_user: "noxadmin@AD.NOXVFX.COM"
    domain_realm: "AD.NOXVFX.COM"
    domain_admin_password: "{{ vault_domain_password | default('') }}"
    
    # NFS configuration
    nfs_server: "192.168.11.9"
    
    # Public mounts (all users)
    nfs_mounts_public:
      - { src: "/volume1/Projects", dest: "Projects" }
      - { src: "/volume1/Library", dest: "Library" }
    
    # Restricted mounts (NOX Admins only)
    nfs_mounts_noxadmins:
      - { src: "/volume1/Archive", dest: "Archive" }
      - { src: "/volume2/Expansion1", dest: "Expansion" }

  tasks:
    - name: Update all packages
      ansible.builtin.dnf:
        name: "*"
        state: latest
      register: system_update

    - name: Reboot if kernel was updated
      ansible.builtin.reboot:
        reboot_timeout: 300
      when: system_update.changed and 'kernel' in system_update.results | string

    - name: Install required packages for domain joining
      ansible.builtin.dnf:
        name:
          - realmd
          - sssd
          - oddjob
          - oddjob-mkhomedir
          - adcli
          - samba-common-tools
          - krb5-workstation
          - nfs-utils
          - autofs
          - policycoreutils-python-utils
        state: present

    - name: Start and enable required services
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: started
        enabled: yes
      loop:
        - realmd
        - sssd
        - oddjobd

    - name: Check if system is already joined to domain
      ansible.builtin.command: realm list
      register: realm_status
      changed_when: false
      failed_when: false

    - name: Discover the domain
      ansible.builtin.command: "realm discover {{ domain_name }}"
      register: realm_discover
      when: domain_name not in realm_status.stdout

    - name: Display domain discovery results
      ansible.builtin.debug:
        var: realm_discover.stdout_lines
      when: realm_discover is defined

    - name: Prompt for domain admin password if not provided
      ansible.builtin.pause:
        prompt: "Enter password for {{ domain_admin_user }}"
        echo: no
      register: password_prompt
      when: 
        - domain_admin_password == ""
        - domain_name not in realm_status.stdout

    - name: Set domain password from prompt
      ansible.builtin.set_fact:
        domain_admin_password: "{{ password_prompt.user_input }}"
      when: password_prompt is defined and password_prompt.user_input is defined

    - name: Join the domain
      ansible.builtin.expect:
        command: "realm join -U {{ domain_admin_user }} {{ domain_controller }} -v"
        responses:
          Password for *: "{{ domain_admin_password }}"
        timeout: 60
      register: domain_join_result
      when: domain_name not in realm_status.stdout

    - name: Display domain join results
      ansible.builtin.debug:
        var: domain_join_result
      when: domain_join_result is defined

    - name: Configure SSSD
      ansible.builtin.copy:
        content: |
          [sssd]
          domains = {{ domain_name }}
          config_file_version = 2
          services = nss, pam

          [domain/{{ domain_name }}]
          default_shell = /bin/bash
          ad_server = {{ domain_controller }}
          krb5_store_password_if_offline = True
          cache_credentials = True
          krb5_realm = {{ domain_realm }}
          realmd_tags = manages-system joined-with-adcli
          id_provider = ad
          fallback_homedir = /home/%d/%u
          ad_domain = {{ domain_name }}
          use_fully_qualified_names = False
          ldap_id_mapping = True
          access_provider = ad
        dest: /etc/sssd/sssd.conf
        mode: '0600'
        owner: root
        group: root
        backup: yes
      notify: restart sssd

    # ====== FIX AD HOME DIRECTORY PERMISSIONS ======
    - name: Set SELinux file context for AD home directories
      ansible.builtin.command: semanage fcontext -a -t user_home_dir_t "/home/{{ domain_name }}(/.*)?"
      register: semanage_result
      failed_when: false
      changed_when: semanage_result.rc == 0

    - name: Apply SELinux contexts to existing AD home directories
      ansible.builtin.command: restorecon -R -v /home/{{ domain_name }}/
      when: semanage_result.rc == 0
      ignore_errors: yes

    - name: Create PAM script directory
      ansible.builtin.file:
        path: /usr/share/libpam-script
        state: directory
        mode: '0755'

    - name: Create script to fix home directory ownership on login
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # Fix home directory ownership for AD users
          # This runs after oddjob creates the directory
          
          USER_HOME=$(eval echo ~$PAM_USER)
          
          if [ -d "$USER_HOME" ]; then
              # Get the actual UID and GID of the user
              USER_UID=$(id -u "$PAM_USER")
              USER_GID=$(id -g "$PAM_USER")
              
              # Fix ownership of the home directory itself if it's owned by root
              HOME_OWNER=$(stat -c '%U' "$USER_HOME")
              if [ "$HOME_OWNER" = "root" ]; then
                  chown "$USER_UID:$USER_GID" "$USER_HOME"
                  chmod 700 "$USER_HOME"
                  logger "Fixed home directory ownership for $PAM_USER"
              fi
              
              # Ensure correct permissions on home directory
              chmod 700 "$USER_HOME"
              
              # Restore SELinux context
              restorecon -R "$USER_HOME" 2>/dev/null || true
          fi
          
          exit 0
        dest: /usr/share/libpam-script/pam_script_homedir_fix.sh
        mode: '0755'

    - name: Create PAM script to setup .config directory on first login
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # Setup .config directory for AD users on login
          
          USER_HOME=$(eval echo ~$PAM_USER)
          
          if [ -d "$USER_HOME" ]; then
              # Create .config directory if it doesn't exist
              if [ ! -d "$USER_HOME/.config" ]; then
                  mkdir -p "$USER_HOME/.config/dconf"
                  
                  # Set ownership
                  USER_UID=$(id -u "$PAM_USER")
                  USER_GID=$(id -g "$PAM_USER")
                  chown -R "$USER_UID:$USER_GID" "$USER_HOME/.config"
                  
                  # Set permissions
                  chmod 700 "$USER_HOME/.config"
                  chmod 700 "$USER_HOME/.config/dconf"
                  
                  # Restore SELinux context
                  restorecon -R "$USER_HOME/.config" 2>/dev/null || true
                  
                  logger "Created .config directory for $PAM_USER"
              fi
              
              # Fix permissions if .config exists but is not writable
              if [ -d "$USER_HOME/.config" ] && [ ! -w "$USER_HOME/.config" ]; then
                  USER_UID=$(id -u "$PAM_USER")
                  USER_GID=$(id -g "$PAM_USER")
                  chown -R "$USER_UID:$USER_GID" "$USER_HOME/.config"
                  chmod 700 "$USER_HOME/.config"
                  restorecon -R "$USER_HOME/.config" 2>/dev/null || true
                  logger "Fixed .config permissions for $PAM_USER"
              fi
          fi
          
          exit 0
        dest: /usr/share/libpam-script/pam_script_config_setup.sh
        mode: '0755'

    - name: Fix existing AD home directories ownership
      ansible.builtin.shell: >
        for user_dir in /home/{{ domain_name }}/*/; do
          if [ -d "$user_dir" ]; then
            username=$(basename "$user_dir");
            home_owner=$(stat -c '%U' "$user_dir");
            if [ "$home_owner" = "root" ]; then
              user_uid=$(id -u "$username" 2>/dev/null);
              user_gid=$(id -g "$username" 2>/dev/null);
              if [ -n "$user_uid" ] && [ -n "$user_gid" ]; then
                chown "$user_uid:$user_gid" "$user_dir";
                chmod 700 "$user_dir";
                restorecon -R "$user_dir" 2>/dev/null || true;
                echo "Fixed ownership for $username";
              fi;
            fi;
          fi;
        done
      args:
        executable: /bin/bash
      register: fix_homes_result
      changed_when: "'Fixed ownership' in fix_homes_result.stdout"
      when: ansible_facts['file']['/home/' + domain_name] is defined or true
      ignore_errors: yes

    - name: Display fixed home directories
      ansible.builtin.debug:
        msg: "{{ fix_homes_result.stdout_lines }}"
      when: fix_homes_result.stdout_lines | length > 0

    - name: Add domain groups to sudoers
      ansible.builtin.lineinfile:
        path: /etc/sudoers
        line: "{{ item }}"
        state: present
        validate: 'visudo -cf %s'
        backup: yes
      loop:
        - "%domain\\ admins ALL=(ALL:ALL) ALL"
        - "%nox-admins ALL=(ALL:ALL) ALL"

    - name: Configure idmapd.conf for NFS
      ansible.builtin.lineinfile:
        path: /etc/idmapd.conf
        regexp: '^#?Domain\s*='
        line: "Domain = {{ domain_name }}"
        backup: yes

    # Autofs configuration using DIRECT maps to avoid /mnt conflicts
    - name: Configure autofs master map for direct mounts (no timeout)
      ansible.builtin.lineinfile:
        path: /etc/auto.master
        regexp: '^/[-mnt]'
        line: "/- /etc/auto.direct --timeout=0"
        state: present
        backup: yes
      notify: restart autofs

    - name: Create autofs direct map file for public mounts
      ansible.builtin.copy:
        content: |
          # Public mounts (all users) - DIRECT MAP
          {% for mount in nfs_mounts_public %}
          /mnt/{{ mount.dest }} -fstype=nfs,rw {{ nfs_server }}:{{ mount.src }}
          {% endfor %}
        dest: /etc/auto.direct
        mode: '0644'
        backup: yes
      notify: restart autofs

    - name: Start and enable autofs service
      ansible.builtin.systemd:
        name: autofs
        state: started
        enabled: yes

    # Set Library permissions for nox-admins write access
    - name: Get nox-admins group GID
      ansible.builtin.command: getent group nox-admins
      register: noxadmins_group
      changed_when: false
      failed_when: false

    - name: Extract nox-admins GID
      ansible.builtin.set_fact:
        noxadmins_gid: "{{ noxadmins_group.stdout.split(':')[2] }}"
      when: noxadmins_group.rc == 0

    - name: Set Library directory ownership for nox-admins write access
      ansible.builtin.file:
        path: /mnt/Library
        owner: root
        group: "{{ noxadmins_gid }}"
        mode: '2775'
        state: directory
      when: noxadmins_gid is defined

    - name: Apply permissions recursively to Library (background task)
      ansible.builtin.shell: |
        nohup chown -R root:{{ noxadmins_gid }} /mnt/Library > /dev/null 2>&1 &
        nohup chmod -R 2775 /mnt/Library > /dev/null 2>&1 &
      args:
        executable: /bin/bash
      when: noxadmins_gid is defined
      async: 7200
      poll: 0
      register: library_perms_job


    - name: Create script to add NFS bookmarks to GNOME Files
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # This script adds NFS mounts as bookmarks in GNOME Files
          
          USER_HOME=$(eval echo ~$PAM_USER)
          BOOKMARKS_FILE="$USER_HOME/.config/gtk-3.0/bookmarks"
          
          # Create gtk-3.0 config directory if it doesn't exist
          mkdir -p "$USER_HOME/.config/gtk-3.0"
          
          # Add public mounts bookmarks for all users
          {% for mount in nfs_mounts_public %}
          BOOKMARK="file:///mnt/{{ mount.dest }} {{ mount.dest }}"
          if ! grep -Fxq "$BOOKMARK" "$BOOKMARKS_FILE" 2>/dev/null; then
              echo "$BOOKMARK" >> "$BOOKMARKS_FILE"
          fi
          {% endfor %}
          
          # Add NOX Admins bookmarks if user is member of the group
          if id -nG "$PAM_USER" | grep -qw "nox-admins"; then
              {% for mount in nfs_mounts_noxadmins %}
              BOOKMARK="file:///mnt/{{ mount.dest }} {{ mount.dest }}"
              if ! grep -Fxq "$BOOKMARK" "$BOOKMARKS_FILE" 2>/dev/null; then
                  echo "$BOOKMARK" >> "$BOOKMARKS_FILE"
              fi
              {% endfor %}
          fi
          
          # Set correct ownership - use UID instead of group name to avoid space issues
          USER_UID=$(id -u "$PAM_USER")
          USER_GID=$(id -g "$PAM_USER")
          chown "$USER_UID:$USER_GID" "$BOOKMARKS_FILE"
          chmod 644 "$BOOKMARKS_FILE"
          
          exit 0
        dest: /usr/share/libpam-script/pam_script_bookmarks.sh
        mode: '0755'
        backup: yes

    - name: Create PAM session script for NOX Admins mounts and bookmarks
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # This script runs when a user logs in
          
          # Fix home directory ownership first (critical!)
          /usr/share/libpam-script/pam_script_homedir_fix.sh
          
          # Setup .config directory
          /usr/share/libpam-script/pam_script_config_setup.sh
          
          # Check if user is member of "nox-admins" group (as seen by Linux)
          if id -nG "$PAM_USER" | grep -qw "nox-admins"; then
              # Add NOX Admins mounts to auto.direct if not present (DIRECT MAP format)
              {% for mount in nfs_mounts_noxadmins %}
              if ! grep -q "^/mnt/{{ mount.dest }}" /etc/auto.direct; then
                  echo "/mnt/{{ mount.dest }} -fstype=nfs,rw {{ nfs_server }}:{{ mount.src }}" >> /etc/auto.direct
              fi
              {% endfor %}
              
              # Reload autofs
              systemctl reload autofs
          fi
          
          # Add bookmarks to GNOME Files
          /usr/share/libpam-script/pam_script_bookmarks.sh
          
          exit 0
        dest: /usr/share/libpam-script/pam_script_ses_open
        mode: '0755'
        backup: yes

    - name: Configure PAM to use the script
      ansible.builtin.lineinfile:
        path: /etc/pam.d/system-auth
        line: "session optional pam_exec.so /usr/share/libpam-script/pam_script_ses_open"
        insertafter: "^session.*pam_systemd"
        state: present
        backup: yes

    - name: Test NFS connectivity before mounting
      ansible.builtin.command: "showmount -e {{ nfs_server }}"
      register: nfs_exports
      failed_when: false
      changed_when: false

    - name: Display NFS exports
      ansible.builtin.debug:
        msg: "Available NFS exports: {{ nfs_exports.stdout_lines }}"
      when: nfs_exports.rc == 0

    - name: Verify domain join status
      ansible.builtin.command: realm list
      register: final_realm_status
      changed_when: false

    - name: Display final domain status
      ansible.builtin.debug:
        msg: "Domain join status: {{ 'SUCCESS' if domain_name in final_realm_status.stdout else 'FAILED' }}"

    - name: Test domain user authentication (optional)
      ansible.builtin.command: "id {{ domain_admin_user.split('@')[0] }}"
      register: user_test
      failed_when: false
      changed_when: false

    - name: Reboot system to complete domain join
      ansible.builtin.reboot:
        reboot_timeout: 300
        msg: "Rebooting to complete domain join process"
      when: domain_join_result is defined and domain_join_result.changed

  handlers:
    - name: restart sssd
      ansible.builtin.systemd:
        name: sssd
        state: restarted
        daemon_reload: yes

    - name: restart autofs
      ansible.builtin.systemd:
        name: autofs
        state: restarted
